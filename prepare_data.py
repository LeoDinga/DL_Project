# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18nLqahOF7btER34OpDZtg10fEMBU4ord
"""

import os
import cv2
import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader, random_split
import torchvision.transforms as T
import torchvision.models as models
from PIL import Image
import numpy as np
from sklearn.metrics import accuracy_score
import shutil
import random

#NÃO SEI SE É NECESSÁRIO
print("CUDA available:", torch.cuda.is_available())
print("Device name:", torch.cuda.get_device_name(0) if torch.cuda.is_available() else "No GPU")

#shows the videos in each folder
data_path = 'data'

# Print out the directory structure
for root, dirs, files in os.walk(data_path):
    print(f"Root: {root}")
    print(f"Dirs: {dirs}")
    print(f"Files: {files}")
    print("-" * 40)

def convert_video_to_npy(video_path):
    cap = cv2.VideoCapture(video_path)
    frames = []

    while True:
        ret, frame = cap.read()
        if not ret:
            break
        # Resize frames if needed (e.g., 224x224)
        frame = cv2.resize(frame, (224, 224))
        frames.append(frame)

    cap.release()

    # Convert list of frames into a numpy array
    frames_array = np.array(frames)
    return frames_array

def create_subfolders(pastas_dir, output_dir):

    for pastas_filename in os.listdir(pastas_dir):
        origem_path = os.path.join(pastas_dir, pastas_filename)

    # Verifica se é uma pasta (ignora arquivos)
        if os.path.isdir(origem_path):
            nova_pasta_path = os.path.join(output_dir, pastas_filename)
            os.makedirs(nova_pasta_path, exist_ok=True)
            #print(f"Criada pasta: {nova_pasta_path}")
        videos_dir = pastas_dir+'/'+pastas_filename
        folder_path = output_dir +'/'+pastas_filename

        for video_filename in os.listdir(videos_dir):
            #print(video_filename)
            if video_filename.endswith(".avi"):  # Process only .avi files

                video_path = os.path.join(videos_dir, video_filename)
                video_name = os.path.splitext(video_filename)[0]

                # Convert the video to numpy array
                frames_array = convert_video_to_npy(video_path)

                # Save the numpy array to a .npy file
                output_filename = os.path.join(folder_path, f"{video_name}.npy")
                np.save(output_filename, frames_array)
                #print(f"Saved {video_filename} as {output_filename}")


pastas_dir = 'data/VIDEO_Skelet3D'  # Directory with .avi videos
npy_dir = 'data/npy_videos'  # Directory to save .npy files
os.makedirs(npy_dir, exist_ok=True)
create_subfolders(pastas_dir, npy_dir)

# def extract_frames_from_npy(npy_file, num_frames=120):
#     # Load the numpy array (which contains all frames of the video)
#     frames = np.load(npy_file)

#     # Calculate indices to extract 120 evenly spaced frames
#     total_frames = frames.shape[0]
#     frame_indices = np.linspace(0, total_frames - 1, num_frames, dtype=int)

#     # Extract the frames
#     extracted_frames = frames[frame_indices]

#     return extracted_frames

def extract_frames_from_npy(npy_file, num_frames=120):
  frames = np.load(npy_file)
  total_frames = frames.shape[0]

  if total_frames < num_frames: #padding
      # Padding com o último frame
      pad_frames = np.repeat(frames[-1:], num_frames - total_frames, axis=0)
      frames = np.concatenate([frames, pad_frames], axis=0)
      #total_frames = frames.shape[0]

  elif total_frames > num_frames: #truncate
      frames = frames[:num_frames]

  return frames

def process_npy_videos_to_frames(npy_dir, output_dir, num_frames=120):

    for npy_subfiles in os.listdir(npy_dir):
       for npy_filename in os.listdir(npy_dir+"/"+npy_subfiles):


          if npy_filename.endswith(".npy"):  # Process only .npy files
              npy_file = os.path.join(npy_dir+'/'+npy_subfiles, npy_filename)
              #video_name = os.path.splitext(npy_filename)[0]

              # Extract 120 frames from the .npy file
              extracted_frames = extract_frames_from_npy(npy_file, num_frames)

              # Save the extracted frames as a new .npy file
              output_filename = os.path.join(output_dir, npy_filename)
              #np.save(output_filename, extracted_frames)
              output_filename = os.path.join(output_dir, npy_filename)
              compressed_filename = output_filename.replace('.npy', '.npz')
              #comprimir ficheiros .npy que contem os frames
              np.savez_compressed(output_filename.replace('.npy', '.npz'), frames=extracted_frames)
              #print(f"Saved 120 frames from {npy_filename} as {output_filename}")
              print(f"Saved 120 frames from {npy_filename} as {compressed_filename}")

# Example usage:
npy_dir = 'data/npy_videos'  # Directory with .npy files
output_dir = 'data/120_frames'  # Directory to save 120 frames
os.makedirs(output_dir, exist_ok=True)

process_npy_videos_to_frames(npy_dir, output_dir)

#eliminar pastas de videos do dataset desnecessárias para o projeto em questão
!rm -r data/VIDEO_Depth data/VIDEO_Mask data/VIDEO_Skelet2D data/papers/
#eliminar pasta npy_videos uma vez que já foi usada
!rm -r data/npy_videos

from google.colab import drive
drive.mount('/content/drive')

def split_by_player(video_dir, output_dir, train_ratio=0.7, val_ratio=0.15, test_ratio=0.15):
    # Step 1: Get a list of all players
    players = set()  # Set to store unique players (assuming folder names represent players)

    for video_filename in os.listdir(video_dir):
        if video_filename.endswith(".npy"):  # Only process .npy files
            player_name = video_filename.split('_')[0]  # Assuming player info is in the filename
            players.add(player_name)

    # Step 2: Shuffle the list of players
    players = list(players)
    random.shuffle(players)

    # Step 3: Split players into train/val/test sets
    num_players = len(players)
    train_size = int(train_ratio * num_players)
    val_size = int(val_ratio * num_players)

    train_players = players[:train_size]
    val_players = players[train_size:train_size + val_size]
    test_players = players[train_size + val_size:]

    # Step 4: Create directories for train/val/test sets
    train_dir = os.path.join(output_dir, 'train')
    val_dir = os.path.join(output_dir, 'val')
    test_dir = os.path.join(output_dir, 'test')

    os.makedirs(train_dir, exist_ok=True)
    os.makedirs(val_dir, exist_ok=True)
    os.makedirs(test_dir, exist_ok=True)

    # Step 5: Move videos to their respective directories
    for video_filename in os.listdir(video_dir):
        if video_filename.endswith(".npy"):
            player_name = video_filename.split('_')[0]  # Get the player name
            src_path = os.path.join(video_dir, video_filename)

            if player_name in train_players:
                dst_dir = train_dir
            elif player_name in val_players:
                dst_dir = val_dir
            else:
                dst_dir = test_dir

            # Move the file to the appropriate directory
            shutil.copy(src_path, os.path.join(dst_dir, video_filename))
            #(f"Moved {video_filename} to {dst_dir}")

# Example usage:
video_dir = 'data/120_frames/'  # Directory containing all the .npy files
output_dir = 'data/splits/'  # Directory where train/val/test splits will be saved
os.makedirs(output_dir, exist_ok=True)

split_by_player(video_dir, output_dir)